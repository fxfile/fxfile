//
// Copyright (c) 2001-2013 Leon Lee author. All rights reserved.
//
//   homepage: http://www.flychk.com
//   e-mail:   mailto:flychk@flychk.com
//
// Use of this source code is governed by a GPLv3 license that can be
// found in the LICENSE file.

#include "stdafx.h"
#include "crc_create.h"

#include "crc_checksum.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

namespace fxfile
{
namespace cmd
{
CrcCreate::CrcCreate(void)
    : mHwnd(XPR_NULL), mMsg(XPR_NULL)
    , mProcessedCount(0), mSucceededCount(0)
    , mMethod(0), mEach(XPR_FALSE)
    , mStatus(StatusNone)
{
}

CrcCreate::~CrcCreate(void)
{
    stop();

    mPathDeque.clear();
}

void CrcCreate::setOwner(HWND aHwnd, xpr_uint_t aMsg)
{
    mHwnd = aHwnd;
    mMsg  = aMsg;
}

void CrcCreate::setMethod(xpr_sint_t aMethod)
{
    mMethod = aMethod;
}

void CrcCreate::setEach(xpr_bool_t aEach)
{
    mEach = aEach;
}

void CrcCreate::setPath(const xpr_tchar_t *aPath)
{
    if (XPR_IS_NOT_NULL(aPath))
        mPath = aPath;
}

void CrcCreate::addPath(const xpr::string &aPath)
{
    mPathDeque.push_back(aPath);
}

xpr_size_t CrcCreate::getCount(void)
{
    return mPathDeque.size();
}

const xpr_tchar_t *CrcCreate::getPath(xpr_sint_t aIndex)
{
    if (!FXFILE_STL_IS_INDEXABLE(aIndex, mPathDeque))
        return XPR_NULL;

    return mPathDeque[aIndex].c_str();
}

xpr_bool_t CrcCreate::start(void)
{
    mProcessedCount = 0;
    mSucceededCount = 0;
    mStatus = StatusCreating;

    xpr_rcode_t sRcode = mThread.start(dynamic_cast<xpr::Thread::Runnable *>(this));

    return XPR_RCODE_IS_SUCCESS(sRcode);
}

void CrcCreate::stop(void)
{
    mThread.stop();
    mThread.join();
}

xpr_sint_t CrcCreate::runThread(xpr::Thread &aThread)
{
    xpr_rcode_t sRcode;
    xpr_sint_t sOpenMode = xpr::FileIo::OpenModeCreate | xpr::FileIo::OpenModeTruncate | xpr::FileIo::OpenModeWriteOnly;
    xpr::FileIo sFileIo;
    xpr::TextFileWriter *sTextFileWriter;

    if (XPR_IS_FALSE(mEach))
    {
        sRcode = sFileIo.open(mPath, sOpenMode);
        if (XPR_RCODE_IS_SUCCESS(sRcode))
        {
            sTextFileWriter = new xpr::TextFileWriter(sFileIo);
            sTextFileWriter->setEncoding((sizeof(xpr_tchar_t) == 2) ? xpr::CharSetUtf16 : xpr::CharSetMultiBytes);
            sTextFileWriter->setEndOfLine(xpr::TextFileWriter::kUnixStyle);
            sTextFileWriter->writeBom();

            if (mMethod == 0)
            {
                sTextFileWriter->writeLine(XPR_STRING_LITERAL("; Generated by WIN-SFV32 v1.0 (Compatible: fxfile)"));
            }
        }
    }

    if (XPR_IS_TRUE(mEach) || (XPR_IS_FALSE(mEach) && sFileIo.isOpened() == XPR_TRUE))
    {
        xpr_char_t sCrcValueA[0xff];
        xpr_tchar_t sCrcValue[0xff];

        xpr_sint_t i;
        xpr_bool_t sResult = XPR_TRUE;
        const xpr_tchar_t *sExt;
        xpr_size_t sInputBytes;
        xpr_size_t sOutputBytes;
        xpr::string sPath;
        xpr::string sFileName;
        xpr::string sCrcPath;
        PathDeque::iterator sIterator;

        sIterator = mPathDeque.begin();
        for (i = 0; sIterator != mPathDeque.end(); ++sIterator, ++i)
        {
            if (mThread.isStop() == XPR_TRUE)
                break;

            sPath = *sIterator;

            if (XPR_IS_TRUE(mEach))
            {
                sCrcPath = sPath;

                sExt = GetFileExt(sCrcPath.c_str());
                if (XPR_IS_NOT_NULL(sExt))
                    sCrcPath.erase(sCrcPath.length()-_tcslen(sExt), _tcslen(sExt));

                sCrcPath += (mMethod == 0) ? XPR_STRING_LITERAL(".sfv") : XPR_STRING_LITERAL(".md5");

                sRcode = sFileIo.open(sCrcPath, sOpenMode);
                if (XPR_RCODE_IS_ERROR(sRcode))
                    continue;

                sTextFileWriter = new xpr::TextFileWriter(sFileIo);
                sTextFileWriter->setEncoding((sizeof(xpr_tchar_t) == 2) ? xpr::CharSetUtf16 : xpr::CharSetMultiBytes);
                sTextFileWriter->setEndOfLine(xpr::TextFileWriter::kUnixStyle);
                sTextFileWriter->writeBom();

                if (mMethod == 0)
                {
                    sTextFileWriter->writeLine(XPR_STRING_LITERAL("; Generated by WIN-SFV32 v1.0 (Compatible: fxfile)"));
                }
            }

            sCrcValueA[0] = 0;
            sCrcValue [0] = 0;

            if (mMethod == 0)
            {
                getFileCrcSfv(sPath.c_str(), sCrcValueA);
            }
            else
            {
                getFileCrcMd5(sPath.c_str(), sCrcValueA);
            }

            sInputBytes = strlen(sCrcValueA) * sizeof(xpr_char_t);
            sOutputBytes = 0xfe * sizeof(xpr_tchar_t);
            XPR_MBS_TO_TCS(sCrcValueA, &sInputBytes, sCrcValue, &sOutputBytes);
            sCrcValue[sOutputBytes / sizeof(xpr_tchar_t)] = 0;

            sFileName = sPath.substr(sPath.rfind(XPR_STRING_LITERAL('\\'))+1);

            if (mMethod == 0)
            {
                sTextFileWriter->writeFormatLine(XPR_STRING_LITERAL("%s %08s"), sFileName.c_str(), sCrcValue);
            }
            else
            {
                sTextFileWriter->writeFormatLine(XPR_STRING_LITERAL("%s %s"), _tcsupr(sCrcValue), sFileName.c_str());
            }

            if (XPR_IS_TRUE(mEach))
            {
                sFileIo.close();
                XPR_SAFE_DELETE(sTextFileWriter);
            }

            {
                xpr::MutexGuard sLockGuard(mMutex);

                mProcessedCount++;
                if (XPR_IS_TRUE(sResult))
                    mSucceededCount++;
            }
        }

        if (XPR_IS_FALSE(mEach))
        {
            sFileIo.close();
            XPR_SAFE_DELETE(sTextFileWriter);
        }

        {
            xpr::MutexGuard sLockGuard(mMutex);
            mStatus = mThread.isStop() ? StatusStopped : StatusCreateCompleted;
        }
    }
    else
    {
        xpr::MutexGuard sLockGuard(mMutex);
        mStatus = StatusFailed;
    }

    ::PostMessage(mHwnd, mMsg, (WPARAM)XPR_NULL, (LPARAM)XPR_NULL);

    return 0;
}

CrcCreate::Status CrcCreate::getStatus(xpr_size_t *aProcessedCount, xpr_size_t *aSucceededCount)
{
    xpr::MutexGuard sLockGuard(mMutex);

    if (XPR_IS_NOT_NULL(aProcessedCount)) *aProcessedCount = mProcessedCount;
    if (XPR_IS_NOT_NULL(aSucceededCount)) *aSucceededCount = mSucceededCount;

    return mStatus;
}
} // namespace cmd
} // namespace fxfile
